[{"title":"web应用开发与部署——你必须掌握的内容","url":"/2025/11/17/web应用开发与部署——你必须掌握的内容/","content":"\n本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、方法与规范，给大家提供一个参考。\n\n本文适合具有一定经验的初中级前端开发者，如果有相关问题，也欢迎与我交流。\n\n目录\n\n- 项目构建的搭建，关键词：**webpack**、**react/vue cli**，**steamer**，**组件库**\n- 代码的规范约束，关键词：**typescript**、**eslint**、**prettier**\n- 测试与测试部署，关键词：**测试部署方案**、**docker**\n- 日志查看与脚本错误的监控，关键词：**sentry**、**vconsole**、**mlogger**\n- 版本发布更新，关键词：**发布系统**、**灰度发布**\n- 访问量实时监控\n\n### 起步：项目构建的搭建\n\n#### 使用 webpack 搭建脚手架\n\n目前在一般的项目中，我们都会使用 webpack 作为搭建开发环境的基础，而 react 和 vue 也各自提供了 cli 工具用于开发一个中小型项目，react 提供了 eject 功能让我们可以更加自由的配置 webpack，而 vue 脚手架虽然没有提供类似命令，但是借助 webpack 工具链我们几乎也可以自由定制每一个角落。\n\n不过，这里我的建议是，如果是个人项目或小型项目，我们可以基于 react 或 vue 的脚手架进行更改使用，对于一个具备一定规模的项目团队，建议还是自己维护一套单独的 webpack 构建环境，原因如下：\n\n- 由于我们一般需要在项目中接入各类司内工具、支持高级 API 和语法、同时支持 react/vue、构建目录定制化等各类工作，实际上 80% 以上的工作我们都需要在模版之上自行添加，这个时候我们再用脚手架带来的收益已经非常小了，反而还会受制于项目的初始目录结构。\n\n我们在自定义脚手架的 webpack 构建的时候，也需要梳理出一定的目录规范与约束，这样也有利于提高后期脚手架的可维护性和扩展性，一般来说，我们也要对脚手架中的公共部分和项目私有部分进行分离，对于一个具体项目而言，可以不用改动 webpack 的项目公共部分，这样也有利于减少不同项目之间的切换成本，对于我们目前的项目，一般会有如下两个目录：\n\n```\n- project\n\t- project.js\n- config\n\t- feature\n\t- plugins\n\t- rules\n\t- script.js\n\t- webpack.base.js\n```\n\n对于一个项目，只需更改 project 下的配置。\n\n这里我也推荐一个前同事做的[steamer 研发体系](https://github.com/steamerjs)，在从中也可以找到很多相关参考，最简单的方式，就是直接在[steamer-simple](https://github.com/steamerjs/steamer-simple) 的基础上进行扩展。\n\n#### 定制生成目录\n\n生成目录的格式，这里需要单独讲一下。\n\n一般来说，我们生成目录的格式都是要跟发布系统进行结合的，不过也有的时候，我们做项目的时候还没有明确要接入发布系统，或者尚不知道发布系统的格式要求，但是一般情况下我们应当遵循下面的约定：\n\n- js/css/img 等资源文件和 html 文件分离，前者发布到 CDN，后者发布到 http 服务器。\n- html 中引入的文件地址，应当是在构建过程中更新的 CDN 地址，而不是相对路径地址。\n- 如果有离线包（offline 能力需要对应的客户端 webview 支持）等，需要单独一个目录。\n\n对于我们目前的项目而言，一般情况下会有三个生成目录：\n\n```\n- cdn\n- offline # 需要客户端支持该能力\n- webserver\n```\n\n如果一开始我们把所有内容生成到一个目录中了，这给我们后期的改动和维护，都带来很大的隐患。\n\n#### 组件库\n\n组件库这一部分，适合项目开始变得复杂的情况下进行启动，而不建议一开始进行过渡设计，建设组件库能够通过组件复用降低我们的开发成本，同时，组件库也需要专人维护，保持更新。\n\n### 开发：代码的规范约束\n\n对于 js 文件的代码格式，诸如要不要分号、两个还是四个字符缩进等，一只争议不断，本文也不对此进行讨论，但是对于一个团队的项目集合（而不是单个项目）而言，代码风格的统一，是一个非常有必要而且必须要做的事情。\n\n#### typescript\n\n关于 typescript 的相关文章实在太多了，这里也不对此进行详细的说明，其对代码的可读性、规范约束、降低报错风险等都有很好的改进，对于越复杂的项目其效果越明显。\n\n另外， [typescript 入门教程](https://ts.xcatliu.com/)的作者也在我们团队中，这里我想说，如果现在还没有开始使用 typescript，请开始学习并使用 typescript 吧。\n\n#### eslint 与 prettier\n\n除了 typescript 以外，在代码格式方面还建议使用 eslint 和 prettier 来进行代码格式的约束，这里虽然 eslint 和 prettier 两者在某些情景下会有些重叠，但是两者的侧重点不同，eslint 侧重于代码质量的检查并且给出提示，在某种层面上，可以看作是 typescript 的补充，而 prettier 在格式化代码方面更具有优势，并且 prettier 在设计之初就考虑了和 eslint 的集成，所以你可以完全放心的在项目中使用两者，而不用担心出现无法解决的冲突。\n\n另外，eslint 社区中已经形成了很多种最佳实践，而我们团队也设计出了自己的一套 eslint 规则，可以按需[取用](https://github.com/AlloyTeam/eslint-config-alloy)\n\np.s. 目前 tslint 后续计划不在维护，转向 eslint 增强，因此我们在项目中可以不再使用 tslint。\n\n以上这几种代码风格方面的约束，适合项目之初即开始约束，这样在中后期会有巨大的时间成本的节省和效率的提升。\n\n### 协作：使用 git\n\n使用 git 进行协作这里其实包括两个点，使用 git 管理项目与自建 gitlab，后者是一个比较基础性的工作，并且实际上难度并不大，我认为每一个公司都可以使用自建的 gitlab 进行版本管理，这个实际上难度并不大，并且可以有效的保护公司的代码财产，如果你所在的公司还没有，那么这也是你的机会。\n\n在具体的使用 git 中，对于 git 的分支/TAG 管理、PR 规范、提交文件约束等都应当有一套合理的流程，这里我对几点比较重要的进行说明：\n\n- 锁定主干与分支开发，我们在日常开发中禁止直接提交主干，而是只能在分支中进行开发，并且通过 MR 的方式提交到主干。\n- git hooks 检查：我们应该通过 git hooks 进行必要的检查，比如自动化测试、eslint 检查、以及一些项目中必要的检查。\n- MR 检查与 Code Review，这里建议在 Merge Request 的时候做两件事情，一件是 Code Review，不过这个在某些特殊情况下不具备条件，尤其是团队人力紧张的时候，另外一个则是 MR 的 HOOK 触发检查，这个一般需要借助一些持续集成工具来完成，可以说是我们代码在合并主干之前的最后一个关卡。\n\n### 测试：测试与测试部署\n\n测试是代码开发中重要的一个环节，但实际上对于前端开发来说，前端开发工程师一般较少书写测试用例，也并没有专业的测试开发工程师来辅助工作，不过，一般会有配备系统测试工程师在黑盒的情况下进行冒烟测试和功能测试以及整体链路的验收，俗称“点点点”。而这个时候，前端开发要做的就是把程序代码部署到测试服务器上，同时提供一个尽可能真实的场景供测试进行测试。\n\n在笔者经历的项目中，虽然也使用了单元测试、端对端测试，不过这一部分体系并不十分完备，并且可能也不是大多数前端开发者感兴趣的内容，所以这里主要总结如何进行高效的测试部署与发布对接。\n\n一般来说，我们一般会有一台到多台 Linux 测试机，供测试环境部署使用，对于前端项目而言，一般不需要特殊环境，可以进行 webpack 构建以及有 nginx 进行转发即可。\n\n而测试环境的部署，如果是让我们手动登录去部署，显然是不合理的，如果我们纯粹使用 CI 来完成这件事，则对 CI 工具的能力和项目人员素质有一定要求，并且不具备可视化管理能力，容易出错，这里我建议可以维护一个可视化系统来进行测试环境的部署和管理，其整个环节应该是这样的：\n\n```\n本地代码 -> gitlab -> 测试系统部署 -> 对接发布系统\n```\n\n这里的测试系统，实际上是从 gitlab 拉取代码，并且本地执行 build 命令（一般是 `npm run build`）并把构建结果存储在 nginx 可代理的目录即可，出于系统完备性考虑，一般我们会有多台测试机，这里我建议一般拿其中的一台作为构建机，其他的测试机仅提供 nginx 代理能力即可，我们在一台构建机中进行构建，并且将构建结果通过系统命令发送到其他的测试机。\n\n一台构建机可以服务于所有的项目，这里还可能涉及到 webpack、nodejs 版本的维护，我们需要约束各个测试项目构建处在一个相对独立的环境中，我们也可以使用过 Docker 来进行构建，保证隔离。\n\n构建完成后，一般我们借助 Fiddler、Charles、Whistle 等任意一款代理工具，即可以进行测试。\n\n### 监控：日志查看与脚本错误的监控\n\n对于前端项目而言，即使我们已经使用了 typescript、eslint 并且也有了一些测试脚本和系统测试工程师进行的功能测试，我们还是免不了会出现 js 脚本错误，特别是 js 代码的运行环境和设备的多样化，很多错误我们并没有发现，但是产品、运营同学却出现了，或者到了线上在用户设备上出现了。\n\n所以，有两个事情我们必须要做：\n\n1. 日志查看功能（手机端）：现在我们写的大多数 TO C 页面都是在手机端进行，查看 console 非常不方便，我们需要一个线上实时查看 console 的工具。\n2. 我们需要脚本错误日志统计系统来进行错误统计管理与具体错误查看。\n\n对于第一个功能，进行细分，我们需要做这样几件事情：\n\n- 嵌入一个 console 和 网络请求查看器，并且只在特殊情况下才能触发（比如连续点击标题十次、或者使用特定交互手势）\n- 在触发查看器的时候，可以将日志完整地进行上传并分析。\n- 同时可以对该用户进行染色，会自动上传并记录该用户一定时间内后续刷新后操作的全部日志。\n\n不过这里并没有完全实现以上三点的开源库推荐，可以在 [vconsole](https://github.com/Tencent/vConsole) 或者 [mlogger](https://github.com/AlloyTeam/MLogger) 的基础上进行适当扩展，完成相关功能。\n\n对于第二个功能，我们需要一个完整的统计分析与管理的错误系统，这个如果自行开发的话，难度会比较大，这里强烈推荐 [sentry](https://sentry.io/welcome/)，可以非常方便的使用 Docker 部署到服务器端，并且拥有非常强大的日志错误分析与处理能力，通过结合 JavaScript 的 sourcemap ，可以给我们的错误定位带来极大的方便。\n\n总之，日志查看与脚本错误监控，是比较重要但是同时容易被忽视的地方，很多时候，我们的系统在线上使用了几个月了，真正有问题反馈了，我们才会考虑加上这些功能，但这个时候通常已经造成了损失。\n\n### 发布：版本发布更新\n\n发布系统，一般作为前端最后环节的系统，通常会和测试部署系统打通（或合二为一），一般的发布系统的必要功能如下：\n\n- 对于前端的发布，每次只发布有改变的文件，无变动的文件则无需发布。\n- 每次发布先发布 js/css/img 等资源文件，生效之后再发布 html 文件。\n- 发布系统保留线上旧版代码，出问题后可以快速一键回滚。\n\n至于一些其他的日志、报表等辅助性功能，则根据需要满足，这里不再赘述。\n\n#### 灰度发布\n\n灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如 1-5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量较大的页面。\n\n对于前端的灰度，实际上有以下几种方案：\n\n- 在代码层面进行灰度，即通过 if/else 进行判断，这样无需发布系统关注，也可以自由配置规则、比例与白名单/黑名单。\n- 在入口层面进行灰度，比如 App 内嵌的 H5 则在客户端的对应入口进行回复，这样通常也无需发布系统关注。\n- 通过发布系统，按照比例灰度，比如我们有 10 台 webserver，如果我们先发布 1 台，这样我们的灰度比例为 10%。\n\n### 访问量实时监控\n\n最后一点，我们还需要一个访问量实时监控系统，我们上述有了错误查看与脚本监控系统，但是对于我们的各个页面的访问量、点击率等指标，通常是产品/运营同学比较关心的，同时访问量的波动情况也是项目健康度的一个表征（访问量突然大幅上涨或下跌，一般都有其特定原因），所以我们需要访问量实时监控系统。\n\n而实际上访问量监控系统也有两种不同形态：\n\n- 对于每一个上报 key，只进行数量上的统计\n- 对于每一个上报 key，可以携带一些信息，对携带信息进行统计分析。\n\n通常情况下，前者的功能是实时或者低延时的，而后者由于需要一部分统计分析，通常可以接受非实时情况（一般每天出前一天的报表）。\n\n这部分内容，需要较强的后端接口稳定性，通常前端需要和对应岗位的同学共建。\n\n### 总结\n\n总结下来，我们一个稳定的前端项目，至少涉及到以下环节：\n\n- 完善的项目脚手架与代码约束规范\n- 内部 gitlab\n- 可视化管理的测试部署系统\n- 实时日志查看工具\n- 脚本错误统计管理系统\n- 发布管理系统\n- 访问量实时监控系统\n\n如果你所在的团队哪个环节还没有或者不完善，那么这也是你的机会。\n","tags":["前端构建"]},{"title":"electron可能不是你的解药","url":"/2025/11/17/electron可能不是你的解药/","content":"\n[Electron](https://www.electronjs.org/docs) (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。\n\n也就是说，我们几乎可以使用纯 web 技术，来创建跨平台的 windows 和 macOS 的原生应用，并通过 Node.js addon 能力接入 native 模块。目前市面上，也有一大批知名的应用是使用 Electron 开发的，比如：VS Code、Atom、Microsoft Teams 等（_在 macOS 上面一个简单的判断应用是否使用了 Electron 的办法：在应用的 Contents/Frameworks 里面搜索是否有 Electron Framework.framework_）。\n\n但实际上，这篇文章是希望你在选用 Electron 框架前，需要进行慎重的考虑和评估。国内有很多公司，包括一些一线互联网公司的项目是一开始为了快速迭代选择了 Electron，后续实在无法进一步优化，全部推到重来，这实际上反而不利于整体的项目迭代。\n\n# 架构选型\n\n一般来说，笔者认为有以下几个场景，不适合使用 Electron 进行开发：\n\n## 1. 无页面或者少量页面的应用\n\n这一点很好理解，Electron 的便利性主要体现在页面相关的开发，如果你的应用几乎没有页面，比如只在顶部状态栏区域有一个按钮，显然就没有必要使用 Electron，直接使用原生的技术栈即可。\n\n## 2. 对安装包体积限制较为严格的应用\n\nElectron 由于自身携带的基础设施，导致即使你的业务代码不多，初始安装包也会比较大（毕竟接近一个浏览器的大小），在没有你的业务代码的情况下，未经优化的安装包达到了 60MB 左右，而且通常你需要把 node_modules 一起打进去，所以即使你的业务并不复杂，也很容易产生一个接近 100MB 的安装包。\n\n因此，如果你的业务需要比较极致的包体积优化，那么 Electron 可能并不是一个合适的选择。\n\n## 3. 多窗口应用\n\nElectron 的进程模型为一个主进程 + 若干渲染进程，每一个渲染进程用于展示一个页面，**即使你的页面是 Hello World，内存占用也达到 50 MB 左右**。\n\n也就是说，如果你的应用需要同时展示多个窗口，那么就需要多个渲染进程，这样整体的内存占用就会上涨很多，而实际上我们使用原生或者其他的类 cef 的方案，是可以做到一个进程对应多个窗口的。\n\n## 4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用\n\nElectron 基于 web 架构，所以使用 Electron 开发的应用性能一般来说和 web 比较接近，当然，我们可以通过 Node.js addon 加持的方式让部分场景下性能更高（比如直接使用 c++ 实现一些计算密集型的模块，或者独立出一个非 UI 进程，来处理非 UI 逻辑），不过页面 UI 相关的还是会受限制于 web 的天花板。\n\n所以，一般来说，以下两种情况可能不适用于 Electron：\n\n1. 在 web 场景下，UI 元素操作比较卡顿，达到瓶颈，必须采用性能更高的原生 UI。不过我建议**不要轻易下这个结论**，一般情况下这种性能问题都是写的代码不够极致，建议先从 web 的角度进行性能优化（比如，长列表场景我们可以[通过压缩合成层优化性能](http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/)来数十倍地提高性能）。\n\n2. 对某一项技术有深度依赖，而这项技术在 web 方面存在性能上的天花板。事实上这种情况也并不多见，其中一个合理的场景是视频相关的应用，比如视频会议，或者视频播放器，这类由于 Chrome 本身的渲染流水线的限制，使用 video 标签或者使用 WebGL 都会存在一些性能问题，这个时候我们需要更深入的去进行相关能力的定制，就需要从 Electron 的框架中跳脱出来，或者针对 Electron 进行二次开发。\n\n> 关于 WebGL: 实际上很多 web 开发者会把 WebGL 当作部分场景下性能优化的银弹，但实际上 WebGL 目前存在诸多困境：WebGL 1.0 虽然已经普及，但是其作为 OpenGL ES 2.0 的子集，性能上已经并不特别适用现代硬件架构；而 WebGL 2.0 目前仍然在普及中并且各家厂商意见无法一致；Web GPU 可能是一个更好的解决方案，底层直接对接 D3D12、metal、vulkan 等更底层更先进的图形框架，但目前成熟度不高。\n\n如果你的应用在经过以上分析之后，认为仍然可以使用 Electron 进行开发，那么恭喜你拥有了一个如此高效率的开发方案（如果不行，建议你可以选择其他的解决方案，比如 [QT](https://www.qt.io/)）。\n\n当然在此基础上，我们仍然需要进行充足的性能优化和稳健的架构设计，来让我们应用的可靠性变得更高。\n\n# 性能优化\n\n和 web 不同的是，我们的 native 应用需要更加关注如下三个指标：\n\n## 1. cpu\n\ncpu 占用相关的问题，我们在 web 技术栈中一般也会关注，不过更多的是关注函数的调用耗时，是否存在同步调用的耗时过长导致卡顿等问题。\n\n而在桌面应用程序的场景中，我们需要从整个应用的维度关注 cpu 消耗，并且需要更加重视。\n\n另外一个原因是，在网页场景中，页面的 cpu 占用通常不会特别直观地被用户发现（因为系统层面通常只会体现在浏览器占用 cpu 较多），而在现在的原生场景，用户可以直接在任务管理器中看到我们的应用，如果我们的应用持续有一个较高的 cpu 占用，就会比较容易被用户发现，甚至触发系统告警提示强杀应用，这对我们应用的口碑也是一个比较负面的影响。\n\n## 2. 内存\n\n在桌面应用程序中，内存的使用方式有了一个明显的变化：\n\n原有的 web 页面，通常是用完即走，而对于 native 应用用户一般会打开很久，这也就意味着我们如果一旦产生内存泄漏或者内存占用比较高的情况，对用户的影响是持续并且被不断放大的。\n\n对于 cpu 和内存的分析，我们可以通过以下方式：\n\n1. 开发阶段通过 visual studio 或 instruments 来详细分析我们开发的功能的 cpu 和内存分配情况，发现问题。\n2. 测试发布阶段通过第三方内存分析工具，流程化的分析 cpu 和内存占用并产出报告。\n3. 线上阶段持续监控 cpu 和内存消耗情况，并且上报数据进行统计和监控告警。\n\n## 3. crash 率\n\n实际上在前端领域基本上没有 \"crash\" 这个说法，不过对于 native 应用来说，即使我们的应用是完全采用前端技术栈，也可能存在 crash (crash 在 Electron 的代码），一般这个时候用户的体验是闪退，相对来说算是严重影响用户体验的问题，因此值得我们足够的重视。\n\n对于 crash 问题我们应该做好以下三点：\n\n1. 运行时 crash 监听机制，一般是 sentry 或者直接使用其依赖的 crash_pad。\n2. 符号管理机制，管理我们原生模块，和我们用到的 Electron 对应版本的符号。\n3. 运行时 crash 上报告警机制。\n\n# 架构优化\n\n除了上述性能指标和监控手段，我们可以通过一定的架构优化，来增强系统的可靠性。\n\n## 通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容\n\n这里的作用主要是希望能够借助原生模块的高性能优化 cpu 的占用。\n\nElectron 让我们开发 ui 相关的页面变得非常高效，但是一些逻辑部分，或者和操作系统进行交互的部分，我们还是需要原生开发的手段，毕竟即使使用了 Node.js，也无法直接进行系统调用。\n\n这里我们可以采用 Node.js addon 的方式或者独立进程+进程间通信的方式，两者的好处分别是：\n\naddon：\n\n1. 方便进行内存共享。\n\n独立进程：\n\n1. 通常会增加可靠性，独立进程挂掉后可以单独重启，不影响用户界面。\n2. 需要防止大块的内存重复占用，可以通过共享内存等方式来进行优化。\n\n## 减少或者禁止在渲染进程使用 remote\n\n有的时候，即使 electron 的技术选型适合你的项目，但如果滥用 remote 也会造成整个应用的大量不稳定与卡顿。\n\n实际上，我们可以通过阅读 electron 的源代码发现，remote 模块只是对 IPC 消息的同步封装，方便渲染进程调用主进程的对象和方法，而不必显式发送消息进行进程间通信。所以，由于其屏蔽了内部的进程间通信，在调用的时候基本无感主进程的存在和 IPC 的风险，但事实上这却有卡顿甚至卡死渲染进程的风险。\n\n另外，去掉 remote 还有另外一个好处，就是方便我们项目的 PC 版本和 web 版本进行同构，具有更高的可维护性。\n\n所以针对一般的项目，笔者建议能禁用就禁用 remote，规避此隐患。\n\n## 其他优化\n\n我们可以在代码编写和打包的过程中，做一些其他的优化，在这里，大部分前端的优化比如动态加载、代码分割、图片缓存等大多也都适用 electron 的情况，除此之外，还有一些优化则是：\n\n1. 避免重复打包：\n\n   - **避免 node_modules 和 webpack 重复的打包和引入**，对于 webpack 我们可以使用 webpack-bundle-analyzer 来分析打包体积进行优化\n   - 减少无关文件的打包，可以通过配置针对 electron-builder 的 config 去除无关内容打包，同时可以使用 [node-prune](https://github.com/tj/node-prune) 来去除无用的 node_modules 小文件。\n\n2. **v8-code-cache**:\n\n   - 可以使用 [v8-compile-cache](https://github.com/zertosh/v8-compile-cache) 来进行一定的编译优化\n\n3. 更多可以参考 VSCode 的相关分享：https://www.youtube.com/watch?v=r0OeHRUCCb4\n","tags":["前端综合"]},{"title":"深入浏览器web渲染与优化","url":"/2025/11/17/深入浏览器web渲染与优化/","content":"\n> 本文主要分析和总结 web 内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n- blink 内核的渲染机制\n- chrome 内核架构变迁\n- 分层渲染\n- 动画 & canvas & WebGl\n\n_这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分_\n\n### blink 内核的渲染机制\n\nblink 内核是 Google 基于 Webkit 内核开发的新的分支，而实际上，目前 Chrome 已经采用了 blink 内核，所以，我们接下来的有关分析大多基于 blink 内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的 X5 内核(X5 内核基于安卓的 WebView，目前已经在手机 QQ 等产品中使用，基于 X5 内核的项目累计有数亿 UV，上百亿 PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n- 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n- 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n- 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如 banner 的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n- 硬件加速合成上屏\n- 2D Canvas、Video 的硬件加速\n- GPU 光栅化\n  - GPU 光栅化速度更快，内存和 CPU 的消耗更少\n  - 目前还没有办法对包含复杂矢量绘制的页面进行 GPU 光栅化\n  - GPU 光栅化是未来趋势\n\n### chrome 内核架构变迁\n\n在渲染架构上，chrome 也是经历了诸多变迁，早期的 Chrome 是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的 chrome 的架构实际上有以下缺点：\n\n- Renderer 线程任务繁重\n- 无法实时响应缩放滑动操作\n- 脏区域与滑动重绘区域有冲突\n  - 这里举个场景，假设一个 gif，这个时候如果用户滑动，滑动新的需要绘制的内容和 gif 下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome 现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4 的 Blink 内核架构如下(4.4 之前并不支持 OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n- UI 线程过于繁忙\n- 无法支持 Canvas 的硬件加速以及 WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n- 多线程化(可以充分利用多核心 CPU)\n- 硬件加速(可以利用 GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n> 打开 Chrome 浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(_注意：多个 RenderObject 可能又会对应一个或多个 RenderLayer_)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n- 减少不必要的重新绘制\n- 可以实现较为复杂的动画\n- 能够方便实现复杂的 CSS 样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n- 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n- 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏 H5)。\n- 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的 video、canvas；fixed 元素；混合插件(flash 等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n- 相对位置会发生变化的元素需要分层(比如 banner 图、滚动条)\n- 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n- 较长较大的页面注意总的分层个数\n- 避免某一块区域分层过多，面积过大\n\n(_如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用 GPU 来渲染该层，与一般的 CPU 渲染相比，提升了速度和性能。(我很确定这么做会在 Chrome 中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如 Firefox、Safari 也是适用的)_)\n\n另外值得一提的是，X5 对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS 动画 or JS 动画?\n\n对内核来说，实际上就是 Renderer 线程动画还是 Compositor 线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer 线程是比 Compositor 线程动画性能差的(在中低端尤其明显)\n\n另外，无论是 JS 动画还是 CSS 动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的 CSS 动画属性：\n\n- cursor\n- font-variant\n- opacity\n- orphans\n- perspective\n- perspecti-origin\n- pointer-events\n- transform\n- transform-style\n- widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n- 尽量使用不会引起重绘的 CSS 属性动画，例如 transform、opacity 等\n- 动画一定要避免触发大量元素重新排版或者大面积重绘\n- 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用 requestAnimationFrame 这个 API，这个 API 迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用 CSS 动画，Animation 动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas 上场。\n\n和 CSS 动画相比，2D canvas 的优点是这样的：\n\n- 硬件加速渲染\n- 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是 JS Call 这一部分，执行 opengl 的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n- 图片\n- 文字\n- 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用 OpenGL 渲染，复杂的图形，如曲线等，无法采用 OpenGL 绘制。\n\n对于绘制效率来说，2D Canvas 对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏 canvas 上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n- 通用引擎：threeJS、Pixi\n- VR 视频的专业引擎：krpano、UtoVR\n- H5 游戏引擎：Egret、Layabox、Cocos\n\nWebGL 虽然包含 Web，但本身对前端的要求最低，但是对 OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5 内核对于 WebGl 进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n---\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript 高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n","tags":["性能优化"]},{"title":"深入浏览器web渲染与优化-续","url":"/2025/11/17/深入浏览器web渲染与优化-续/","content":"\n> 本篇文章接上一篇继续分析浏览器 web 渲染相关内容，但是更侧重优化工作。当然，主要还是基于 X5 来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的 API，这些 API 能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，_另外，展示后到用户的第一次操作都会有一个至少 1s 的延时，毕竟用户手指按下的动作是会比较慢的，这个时间 js 的交互都能完成了，所以首屏展示时间更加重要--from dorsywang_)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前 X5 内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响 css、js 的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n- 资源阻塞内核线程\n\n我们知道，一般情况下，css 和 JS 是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5 内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入 Web App Manifest)\n\n- 中文 Layout 的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有 26 个字符)，而中文由于字符比较多，常用得就有 6000 多个，完整的更是有 2 万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5 内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n- 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n- 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5 内核也提供了主资源预拉取的接口，并且考虑到预拉取的 cookie 问题，还提供了 preconnect 预链接。  \n_TIP:主资源中关联的子资源预拉取不用主动调用_\n\n- 预先操作\n\n另外为了提供更加极致的优化，X5 内核(QQ 浏览器、手 Q Webview)还提供了如下诸多预操作：\n\n- 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n- 经常访问的站点可以预解析 DNS\n- 点击地址栏时进行搜索预连接\n- 点击链接时，先预链接，再做跳转。\n- ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n- 直接使用 IP，节省 dns 的查询时间\n- 维持长连接\n- HTTP1.1 启用包头节省\n- 服务器缓存\n- 文本资源压缩传输 GZIP(6)\n- 图片尺寸压缩、图片质量压缩、支持 webp 和 sharpp/hevc 格式。\n\n##### 降低网络时延\n\n- 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是 X5 内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级 http 加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC 和 http2\n\nQUIC 基于 UDP 的协议通讯方式，有这些优势：\n\n- 延迟少\n- 前向纠错\n- 没有**线头阻塞[注 1]**的多路复用\n- 通信通道的定义基于 ID 而不是 IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注 1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附 1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","tags":["性能优化"]},{"title":"构建利用Proxy和Reflect实现双向数据绑定的微框架","url":"/2025/11/17/构建利用Proxy和Reflect实现双向数据绑定的微框架/","content":"\n> 写在前面：这篇文章讲述了如何利用 Proxy 和 Reflect 实现双向数据绑定，个人系 Vue 早期玩家，写这个小框架的时候也没有参考 Vue 等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。\n\n代码下载地址：[这里下载](https://github.com/aircloud/Polar.js)\n\n### 综述\n\n_关于 Proxy 和 Reflect 的资料推荐阮老师的教程:http://es6.ruanyifeng.com/ 这里不做过多介绍。_\n\n实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用 Proxy 和 Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于 ES6，用这些内容也符合面向未来的 JS 编程规范，第三点最后说。\n\n由于这个小框架是自己在 PolarBear 这个咖啡馆在一个安静的午后开始写成，暂且起名 Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。\n\n首先我们可以看整体功能演示：  \n[一个 gif 动图，如果不能看，请点击[这里的链接](https://www.10000h.top/images/data_img/gif1.gif)]\n\n![](https://www.10000h.top/images/data_img/gif1.gif)\n\n### 代码分析\n\n我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。\n\n我的思路是这样的：\n\n- 将所有的数据信息放在一个属性对象中(this.\\_data),之后给这个属性对象用 Proxy 包装 set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。\n- 对于 input 等表单，我们需要监听 input 事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。\n- 我们同时也应该支持事件机制，这里我们以最常用的 click 方法作为例子实现。\n\n下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:\n\n```\n<div id=\"app\">\n    <form>\n        <label>name:</label>\n        <input p-model = \"name\" />\n    </form>\n    <div>name:{{name}} age:{{age}}</div>\n    <i>note:{{note}}</i><br/>\n    <button p-click=\"test(2)\">button1</button>\n</div>\n<script>\n var myPolar = new Polar({\n        el:\"#app\",\n        data: {\n            name: \"niexiaotao\",\n            age:16,\n            note:\"Student of Zhejiang University\"\n        },\n        methods:{\n            test:function(e,addNumber){\n                console.log(\"e:\",e);\n                this.data.age+=Number(addNumber);\n            }\n        }\n});\n</script>\n```\n\n没错，和 Vue 神似吧，所以这种调用方式应当为我们所熟悉。\n\n我们需要建立一个 Polar 类，这个类的构造函数应该进行一些初始化操作:\n\n```\n constructor(configs){\n        this.root = this.el = document.querySelector(configs.el);\n        this._data = configs.data;\n        this._data.__bindings = {};\n        //创建代理对象\n        this.data = new Proxy(this._data, {set});\n        this.methods = configs.methods;\n\n        this._compile(this.root);\n}\n```\n\n这里面的一部份内容是直接将我们传入的 configs 按照属性分别赋值，另外就是我们创建代理对象的过程，最后的`_compile`方法可以理解为一个私有的初始化方法。\n\n实际上我把剩下的内容几乎都放在`_compile`方法里面了，这样理解起来方便，但是之后可能要改动。\n\n我们还是先不能看我们代理的 set 该怎么写，因为这个时候我们还要先继续梳理思路：\n\n假设我们这样`<div>name:{{name}}</div>`将数据绑定到 dom 节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让 dom 节点和数据对应起来，随着数据改变而改变。\n\n看上文的`__bindings`。这个对象用来存储所有绑定的 dom 节点信息，`__bindings`本身是一个对象，每一个有对应 dom 节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的 set 代理函数中，我们一个个调用过去，就可以更新内容了：\n\n```\ndataSet.__bindings[key].forEach(function(item){\n       //do something to update...\n});\n```\n\n我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：\n\n```\nfunction Directive(el,polar,attr,elementValue){\n    this.el=el;//元素本身dom节点\n    this.polar = polar;//对应的polar实例\n    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue\n    this.el[this.attr] = this.elementValue = elementValue;//初始化\n}\n```\n\n这样，我们的 set 可以这样写:\n\n```\nfunction set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n    var dataSet = receiver || target;\n    dataSet.__bindings[key].forEach(function(item){\n        item.el[item.attr] = item.elementValue = value;\n    });\n    return result;\n}\n```\n\n接下来可能还有一个问题：我们的`{{name}}`实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：`<div>name:{{name}} age:{{age}}</div>`？\n\n关于这两个问题，前者的答案是我们将`{{name}}`替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5 的 normalize 方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要 GG 了)\n\n所以我们在`_compile`函数首先：\n\n```\nvar _this = this;\n\n        var nodes = root.children;\n\n        var bindDataTester = new RegExp(\"{{(.*?)}}\",\"ig\");\n\n        for(let i=0;i<nodes.length;i++){\n            var node=nodes[i];\n\n            //如果还有html字节点，则递归\n            if(node.children.length){\n                this._compile(node);\n            }\n\n            var matches = node.innerHTML.match(bindDataTester);\n            if(matches){\n                var newMatches = matches.map(function (item) {\n                    return  item.replace(/{{(.*?)}}/,\"$1\")\n                });\n                var splitTextNodes  = node.innerHTML.split(/{{.*?}}/);\n                node.innerHTML=null;\n                //更新DOM，处理同一个textnode里面多次绑定情况\n                if(splitTextNodes[0]){\n                    node.append(document.createTextNode(splitTextNodes[0]));\n                }\n                for(let ii=0;ii<newMatches.length;ii++){\n                    var el = document.createTextNode('');\n                    node.appendChild(el);\n                    if(splitTextNodes[ii+1]){\n                        node.append(document.createTextNode(splitTextNodes[ii+1]));\n                    }\n                //对数据和dom进行绑定\n                let returnCode = !this._data.__bindings[newMatches[ii]]?\n                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]])]\n                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]]))\n                }\n            }\n\n```\n\n这样，我们的数据绑定阶段就写好了，接下来，我们处理`<input p-model = \"name\" />`这样的情况。\n\n这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：\n\n```\nif(node.hasAttribute((\"p-model\"))\n                && node.tagName.toLocaleUpperCase()==\"INPUT\" || node.tagName.toLocaleUpperCase()==\"TEXTAREA\"){\n                node.addEventListener(\"input\", (function () {\n\n                    var attributeValue = node.getAttribute(\"p-model\");\n\n                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,\"value\",_this.data[attributeValue])) ;\n                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,\"value\",_this.data[attributeValue])];\n\n                    return function (event) {\n                        _this.data[attributeValue]=event.target.value\n                    }\n                })());\n}\n```\n\n请注意，上面调用了一个`IIFE`，实际绑定的函数只有返回的函数那一小部分。\n\n最后我们处理事件的情况：`<button p-click=\"test(2)\">button1</button>`\n\n实际上这比处理`p-model`还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将`event`始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。\n\n```\nif(node.hasAttribute(\"p-click\")) {\n                node.addEventListener(\"click\",function(){\n                    var attributeValue=node.getAttribute(\"p-click\");\n                    var args=/\\(.*\\)/.exec(attributeValue);\n                    //允许参数\n                    if(args) {\n                        args=args[0];\n                        attributeValue=attributeValue.replace(args,\"\");\n                        args=args.replace(/[\\(\\)\\'\\\"]/g,'').split(\",\");\n                    }\n                    else args=[];\n                    return function (event) {\n                        _this.methods[attributeValue].apply(_this,[event,...args]);\n                    }\n                }());\n}\n```\n\n现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约 100 行，所有源代码可以在[这里下载](https://github.com/aircloud/Polar.js)。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。\n\n一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～\n\n---\n\n最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。\n","tags":["MVVM"]},{"title":"代码整洁之道","url":"/2025/11/17/代码整洁之道/","content":"\n## 整洁代码\n\n《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看起来像某种特别在意他的人写的，几乎没有改进的余地，代码的作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给的代码——全心投入某人留给你的代码。\n\n## 函数\n\n这本书关于函数的介绍和其他架构书差不多，主要就是两个点：1. 短小，2. 抽象层次一致性。\n\n## 注释\n\n毫无疑问，注释是代码中的坏味道。\n\n对于一部分注释，我们可以使用类似 4.4.8 这种变量的方式，通过新增两个变量，来解释我们的内容。\n那种生成的注释和我们注释掉的代码，我的建议是：不要留。\n\n## 格式\n\n相关函数：按照本书的说明，若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。我自己之前的习惯是调用者在被调用者的下面，目前又思考了一下，像作者这样组织，可能可读性反而更高。\n\n> 因为这样设计可以像报纸一样，最重要的概念先出现，并且希望以包括最小的细节表述他们，期望底层的细节后出现。\n\n## 错误处理\n\n**使用异常而非返回码**： 在 《代码精进之路》的读书笔记中，也提及了类似的思路，这个书里面又提到了使用异常而非返回码这一点，并且给出了一个新的理由，返回码意味着我们需要立即处理，这个步骤可能很容易被遗忘，而且会让我们的代码变得比较乱。\n\n关于返回 null 值：有的时候，我们在数据处理中出现问题，可能会返回一个 null 或者 undefined。但是我建议相对于此，我们更应该直接抛出异常，返回 null 值意味着依赖调用者来做空检查，而且你不知道这个 null 究竟什么时候才会引发错误，这样会有较高的不稳定性。\n\n## 类的组织\n\n对于类的组织中，属性顺序的一个建议：依次是公共静态常量、私有静态变量、公共函数、私有函数。\n\n**类的权责**：对于一个类来说，我们不希望它被定义的太长，当然这个不能单纯地使用代码行数来判断，我们应该使用类的权责来判断，当一个类的名称越含糊，该类越有可能拥有更多权责，比如它的名称包含了诸如 Processor、Manager 或 Super，那么这种现象往往说明有不恰当的权责聚集的情况出现。\n\n**如何把类拆的短小**：我给出一个切实可行的办法，可以先从类的复杂函数入手，我们在把函数拆分的过程中，发现某些部分拆分成函数之后会传递大量的参数给它，否则很难拆分，那么传递给它这个函数的参数就可以被整合进新的小类的实体变量，这样我们就无需传递参数，同时也完成了拆分。\n","tags":["读书笔记"]},{"title":"《代码精进之路》与《代码整洁之道》读书笔记","url":"/2025/11/17/《代码精进之路》与《代码整洁之道》读书笔记/","content":"\n本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。\n\n> 《代码整洁之道-程序员的职业素养》\n\n## 软件开发原则\n\n所有软件项目的根本指导原则是，软件要**易于修改**。如果违背这条原则搭建僵化的结构，就破坏了构建整个行业的经济模型。\n\n## 必备技能\n\n软件开发人员必须精通的事项：\n\n- 设计模式：必须能描述 GOF 书中的全部 24 种模式和，同时还要有 POSA 书中的多数模型的实践经验。\n- 设计原则：必须了解 SOLID 原则，而且要深刻理解组件设计原则。\n- 方法：必须理解 XP、Scrum、精益、看板、瀑布、结构化和分析以及结构化编程。\n- 实践：必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程。\n- 工作：必须了解如何使用 UML 图，DFD 图，结构图，Petri 网络图，状态迁移图表，流程图和决策表。\n\n## 不要说“我试试”\n\n- 这种类型的描述并不是承诺，实际上并没有实际意义。\n- 而且这通常意味着你之前评估周期的时候**并没有竭尽全力**，否则为什么在压缩周期的讨论中还要再说“我试试”呢。\n\n## 重新定义“完成”\n\n- 有的时候，我们自欺欺人的认为任务已经完成的足够好了，然后转入下一项任务。我们会给自己找借口说，其他还没来得及完成的工作可以等到时间更充裕的时候来处理。甚至有的时候，我们会把代码提交定义为”任务完成“。这样显然是错误的。\n- 真正的任务完成，是已经通过了测试，并且上线完成等。\n\n## 寻求帮助\n\n- 编程并非易事。越年轻的程序员可能越没有感觉，毕竟代码只不过是一堆 if 和 while 语句而已。但是随着经验增长，你会开始意识到把这些 if 和 while 语句组装在一起并非易事。不能期望将他们简单的组装到一起就能得到最好的代码。相反，必须小心谨慎地将系统分解为易于理解的单元，同时使得这些单元之间的联系越少越好。\n- 因此，仅凭一己之力很难写出足够优秀的代码，即使你的技艺足够高超。**也一定能从另外一名程序员的思考和想法中获益。**\n\n## 重新认识争论\n\n- 凡是不能在 5 分钟内解决的争论，都不能通过辩论来解决。争论之所以要花费这么长时间，是因为争论双方都拿不出足够有力的证据，这个时候争论依据的不是事实，而是信念。\n\n## 团队\n\n- 成员需要克服个体差异性，默契配合，彼此信任，形成真正有凝聚力的团队，是需要一些时间的。可能需要 6 个月，甚至一年，但是，凝聚力一旦形成，就会产生一种神奇的魔力。团队成员会一起做计划，一起解决问题，一起面对问题，**一起解决一切**。\n\n> 《代码精进之路》\n\n## 命名\n\n一般来说我们都知道命名应该有可读性，但是像这里介绍这么详细的并不多。\n\n例如我们针对命名可以通过固定分段限定词的方式进行统一：\n\n- `[动作][对象][范畴]`，来统一我们的命名，例如 `getRevenueTotal(获取总收入)`。\n\n## 注释\n\n- 注释如果是对执行过程的简单复述，那么这样的注释不应该存在。\n- 我们可以通过函数和中间变量的封装，来减少可以避免的注释。\n\n## 错误和错误码\n\n我们可以通过以下几种方式处理错误（中后台系统比较合适）：\n\n1. 程序运行期间的错误，一般我们可以通过 Error 打印到日志中，而且这类错误，最好和报警系统进行对接，直接输出到报警系统中。\n2. API/服务调用错误，这种错误一般通过错误码返回给调用端的同时，也需要在日志做好记录。\n\n> 关于错误码：错误码我们可以使用数字或者显示化错误码，数字的坏处即我们需要额外维护错误码表，调用者可能并非我们团队，有可能造成沟通障碍。\n> 因此，更建议使用**显示化错误码**，并且可以做一个约定：P 代表参数异常，B 代表业务异常，S 代表系统异常，例如：P_Customer_NameIsNull 客户姓名不能为空\n\n## 代码中的破窗效应\n\n破窗效应在代码中很常见，通常在我们完成一个功能的时候，都是基于现有代码的改动，如果你可以基于一个现有代码的不良设计完成功能（例如，在已经很混乱的事件订阅类增加一个 Enum、在已经很冗长的 Http 请求列表复制一个新的出来），那么大概率你会这样做而不是重构，**特别是当这个不良设计不是你最初写的时候，就更加可以心安理得的改代码而没有任何负罪感，甚至在 Code Review 的时候都可以有充足的理由：它已经是这样了，这次先上，将来找个时间整体重构才行。**\n\n## SLAP\n\nSLAP：Single Level of Abstraction Principle，抽象层次一致性\n\nSLAP 要求函数体中的内容必须在同一个抽象层次上，如果高层次抽象和低层次细节杂糅在一起，就会显得凌乱，难以理解。\n\n## 如何述职\n\n- 方法 1: **提出问题，定义问题，分析问题，解决问题，最后展望未来**。这个也是麦肯锡常用的方法。\n- 方法 2: 我们说事情的时候，应该像电影镜头一样，先由远拉近，再由近拉远。从宏观背景，到怎么做的，到结果和思考。\n","tags":["读书笔记"]},{"title":"Cookie和Session原理","url":"/2024/08/20/Cookie和Session原理/","content":"\n","tags":["前端"],"categories":["Node"]},{"title":"JS原型链详解","url":"/2024/07/27/JS原型链详解/","content":"\n## 什么是原型\n\n> 在JS中，每个函数在被创建的时候就会有一个prototype属性，这个属性指向一个对象，而这个对象就是这个函数的原型对象(也就是原型)，它是用来共享实例的所有属性和方法\n\n```JS\nvar arr = [1, 2, 3];\narr.__proro__ == Array.prototype; //true\n```\n\n## 什么是原型链\n\n> 原型链：简单点就是原型之间组成的链。当访问一个对象的某个属性时，会优先在自己的对象中查找, 如果找到直接返回，如果没有找到, 那么会在`__proto__` 隐式原型上查找，既它的构造函数的prototype。如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为`原型链`。\n\n```js\nfunction Person(name) {\n    this.name = name\n}\n\nvar p1 = new Person('awen')\n```\n\n","tags":["原型链"],"categories":["前端","面试题"]},{"title":"vue2配置Webpack@别名(路径配置)","url":"/2024/07/24/vue2配置Webpack-别名-路径配置/","content":"\n## 项目目录结构\n\n```markdown\n├── src\n│   ├── api\n│   ├── components\n│   │   └── HelloWorld.vue\n│   ├── assets\n│   ├── styles\n│   ├── utils\n│   └── views\n└── jsconfig.json\n```\n\n## 一：jsconfig.json 配置\n\n在项目的根目录下创建 `jsconfig.json` 文件，可以让 IDE 识别项目的别名（如 `@`）。\n\n### 基本配置\n\n```json\n{\n    \"compilerOptions\": {\n        \"target\": \"es2017\",\n        \"baseUrl\": \"./\",\n        \"paths\": {\n            \"@/*\": [\"src/*\"]\n        }\n    },\n    \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### 复杂配置\n\n你也可以在 `jsconfig.json` 中设置更复杂的别名，以便更好地组织你的项目结构。\n\n```json\n{\n    \"compilerOptions\": {\n        \"baseUrl\": \"./\",\n        \"paths\": {\n            \"@/*\": [\"src/*\"],\n            \"@i/*\": [\"src/api/*\"],\n            \"@c/*\": [\"src/components/*\"],\n            \"@a/*\": [\"src/assets/*\"],\n            \"@s/*\": [\"src/styles/*\"],\n            \"@u/*\": [\"src/utils/*\"],\n            \"@v/*\": [\"src/views/*\"]\n        }\n    },\n    \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## 二：vue.config.js 配置\n\n在 Vue 项目中，你可以通过修改 `vue.config.js` 文件来设置 Webpack 的别名，以便更方便地引入文件。\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n    configureWebpack: {\n        resolve: {\n            alias: {\n                \"@\": path.resolve(__dirname, \"src\"),\n                \"api\": path.resolve(__dirname, \"src/api\"),\n                \"components\": path.resolve(__dirname, \"src/components\"),\n                \"assets\": path.resolve(__dirname, \"src/assets\"),\n                \"styles\": path.resolve(__dirname, \"src/styles\"),\n                \"utils\": path.resolve(__dirname, \"src/utils\"),\n                \"views\": path.resolve(__dirname, \"src/views\")\n            }\n        }\n    }\n};\n```\n\n**注意**：在使用 `path.resolve` 时，需要确保已经导入了 `path` 模块。\n\n通过以上配置，你可以在项目中更方便地使用别名来引入文件，提高开发效率。\n","tags":["Vue2"],"categories":["前端"]},{"title":"Vue2路由跳转报错解决","url":"/2024/07/24/Vue2路由跳转报错解决/","content":"\n## Vue2编程式路由跳转到当前路由(参数不变)，多次执行会抛出如下NavigationDuplicated警告错误？\n\n<img src=\"https://raw.githubusercontent.com/ZenDevon/blog-img/main/vue2路由报错.jpg\" alt=\"img\"  />\n\n### 报错原因\n\n当我们在使用编程式路由进行页面跳转时，多次执行会抛出NavigationDuplicated的警告错误是因为\"[vue-router](https://so.csdn.net/so/search?q=vue-router&spm=1001.2101.3001.7020)\"3版本之后 底层引入了[promise](https://so.csdn.net/so/search?q=promise&spm=1001.2101.3001.7020)。而我们通过声明式导航没有出现此类问题是因为vue-router底层已经处理好了。\n\n### 解决办法\n\n#### 方法一\n\n> 升级vue-router版本为4.0以上即可解决，项目目录下运行命令：\n\n```\nnpm install vue-router@4\n```\n\n#### 方法二\n\n> 修改[VueRouter](https://so.csdn.net/so/search?q=VueRouter&spm=1001.2101.3001.7020)原型对象上的push方法\n\n```javascript\n//重写push | replace 方法\nlet originPush = vueRouter.prototype.push\nlet originReplace = vueRouter.prototype.replace\n/*\n\tLocation：路由地址、传递的参数等\n\tonComplete：promise成功的回调\n\tonAbort：promise失败的回调\n*/\nvueRouter.prototype.push = function(Location, onComplete, onAbort) {\n    if(onComplete && onAbort) {\n        originPush.call(this, Location, onComplete, onAbort)\n    } else {\n        originPush.call(this, Location, () => {}, () => {})\n    }\n}\nvueRouter.prototype.replace = function(Location, onComplete, onAbort) {\n    if(onComplete && onAbort) {\n        originReplace.call(this, Location, onComplete, onAbort)\n    } else {\n        originReplace.call(this, Location, () => {}, () => {})\n    }\n}\n```\n\n","tags":["Vue2"],"categories":["前端"]},{"title":"Less语法学习与实践","url":"/2024/07/21/Less语法学习与实践/","content":"\n[Less](https://less.bootcss.com/#)是一门向后兼容的 CSS 扩展语言。相较于传统的Css，其引入了变量、函数、继承等一些新的概念，帮助我们更方便的书写Css。\n\n---\n\nThe End!\n","tags":["less"],"categories":["前端"]},{"title":"记录CSS3学习","url":"/2024/06/27/记录CSS3学习/","content":"# CSS3新增渐变\n## 线性渐变\n\n多个颜色之间的渐变，默认从上到下渐变\n\n> background-image: linear-gradient(red,  yellow, green)\n\n使用关键词设置线性渐变的方向\n\n\n\n使用角度设置线性渐变的方向\n\n调整开始渐变的位置\n\n## 径向渐变\n## 重复渐变\n","tags":["前端"],"categories":["CSS3"]},{"title":"前端性能优化","url":"/2024/05/29/前端性能优化/","content":"\n# 浏览器功能与组成\n## 浏览器应该有的功能\n\n```\n网络：\n\t浏览器通过网络模块来下载各式各样的资源，例如html文本；javascrip代码；样式表；图片；音视频等。\n\t网路部分尤为重要，因为它耗时长，而且需要安全访问互联网上的资源。\n\n资源管理：\n\t从网络下载，或者本地获取到的资源需要高效的机制来管理它们。\n\t例如如何避免重复下载，资源如何缓存等等\n\n网页浏览：\n\t这是浏览器的核心也是最基本的功能，最重要的功能。\n\t如何将资源转变为可视化的结果。\n\t\n多页面管理\n插件与管理\n账户和同步\n安全机制\n开发者工具\n···\n···\n\n浏览器的主要功能总结起来就一句话：将用户输入的url转变为可视化的图像。\n```\n\n## 浏览器的内核(渲染引擎)\n\n​\t\t在浏览器中有一个最重要的模块，它主要的作用把一切请求回来的资源变为可视化的图像。\n\n​\t\t这个模块就是浏览器内核，通常它也被称为渲染引擎。\n​\t   主流浏览器有 `市场份额` `有自己独特的内核（渲染引擎+js引擎`\n\n### Webkit内核：\n\n最著名的Webkit内核浏览器是苹果公司的Safari浏览器。\n\n- ​\tSafari：苹果公司的官方浏览器，使用Webkit内核。\n- ​\tGoogle Chrome（早期版本）：早期的Chrome浏览器使用了Webkit内核。\n- ​\tOpera（早期版本）：早期的Opera浏览器也使用了Webkit内核。\n\n### Blink内核：\n\nBlink内核是由Google开发的一种浏览器引擎，它是在Webkit内核的基础上经过修改和优化而来。\n\n- Google Chrome：由Google开发的最流行的浏览器，使用Blink内核。\n- Microsoft Edge：微软开发的浏览器，最新版本使用了Chromium内核（也是基于Blink内核）。\n- Opera：最新版本的Opera浏览器也使用了Chromium内核。\n- Vivaldi：一款基于Chromium内核的定制化浏览器，由前Opera团队开发。\n- 360极速浏览器：国内一款流行的浏览器，基于Chromium内核。\n- QQ浏览器：腾讯开发的浏览器，也使用了Chromium内核。\n\n### Gecko内核：\n\nGecko内核是由Mozilla基金会开发的一种浏览器引擎，它用于Mozilla Firefox浏览器。Gecko内核在处理网页布局和渲染方面具有很高的性能和灵活性。\n\n- Mozilla Firefox：由Mozilla基金会开发的浏览器，使用Gecko内核。\n\n### Trident内核：\n\nTrident内核是由微软开发的一种浏览器引擎，它用于Internet Explorer浏览器。Trident内核在过去的几年中已经逐渐被EdgeHTML内核所取代。\n\n- Internet Explorer：微软开发的浏览器，使用Trident内核。\n\n### EdgeHTML内核：\n\nEdgeHTML内核是由微软开发的一种浏览器引擎，它用于Microsoft Edge浏览器。EdgeHTML内核是在Trident内核的基础上进行重写和改进而来。\n\n- Microsoft Edge（旧版）：旧版的Microsoft Edge浏览器使用了EdgeHTML内核。\n\n`需要注意的是，这些浏览器和内核的关系可能随着时间的推移而变化，因此最好使用最新版本的浏览器和正确的内核信息。`\n\n### Chromium、Chrome、Blink三者之间的关系\n\nChromium、Chrome和Blink是三个不同但相关的概念：\n\n1. Chromium：Chromium是一个开源的浏览器项目，由Google发起并维护。它是一个基于开放源代码的浏览器引擎，也是Chrome浏览器的基础。Chromium项目的目标是提供一个稳定、快速、安全的浏览器引擎，供开发人员和其他浏览器厂商使用和修改。\n2. Chrome：Chrome是由Google基于Chromium项目构建的一个浏览器。它是基于Chromium引擎，并添加了一些Google专有的功能，如自动同步、Google账号集成、Google Now等。Chrome浏览器是一个流行的、功能丰富的浏览器，被广泛用于桌面和移动设备上。\n3. Blink：Blink是一个浏览器引擎，它是由Google基于Webkit引擎进行修改和优化而来。Blink引擎最初是作为Chromium项目的一部分开发的，后来被Google Chrome和其他浏览器采用。Blink引擎具有高性能、快速渲染和良好的兼容性，是目前许多主流浏览器的默认引擎。\n\n`总结起来，Chromium是一个开源的浏览器项目，Chrome是基于Chromium项目构建的一个浏览器，而Blink是由Google开发的浏览器引擎，它是Chromium和Chrome的共同引擎。`\n\n## 进程与线程\n\n### 进程：\n\n程序的一次执行，它占有一片独有的内存空间，是操作系统执行的基本单元。类似于工厂。\n\n- 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建\n\n- 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的\n\n- 一个进程内的数据可以供其中多个线程直接共享，多个进程之间的数据是不能直接共享的\n\n### 线程：\n\n- 是进程内的一个独立执行单元，是CPU调度的最小单元。程序运行的基本单元，类似于流水线。\n\n- 线程池(thread poll): 保存多个线程对象的容器，实现线程对象的反复利用\n\n`JS引擎是单线程运行的！（回忆事件轮询机制）`\n\n### 现代浏览器：多进程、多线程模型\n\n- 不堪回首的过去：\n\n  当你通过浏览器打开很多页面的时候,如果其中一个页面不响应了或者崩溃了,\n  那么随之而来的将会是更不幸的事情,你开打的所有页面都会得不到响应,\n  最让人不能忍受的是,其中的一些页面可能还包含了未保存或者未发送的信息\n\n- 浏览器产商如何解决？\n\n  - 采用多进程模型,该模型可以带来的好处\n\n  - 避免因单个页面的不响应或者崩溃影响整个浏览器的稳定性\n\n  - 当第三方插件崩溃时,也不会影响整个浏览器的稳定性\n\n  - 安全\n\n- 浏览器到底有些什么进程`（重要）`\n\n  - Browser进程:\n\n    - 浏览器的主进程,负责浏览器界面的显示,和各个页面的管理\n\n    - 浏览器中所有其他类型进程的祖先,负责其他进程的的创建和销毁\n\n    - `它有且只有一个`\n\n  - Renderer进程:\n\n    - 网页渲染进程,负责页面的渲染,\n\n    - 可以有多个当然渲染进程的数量不一定等于你开打网页的个数\n\n  - 各种插件进程：\n\n  - GPU进程:\n\n    ```\n    移动设备的浏览器可能不太一样:\n    \tAndroid不支持插件,所以就没有插件进程\n    \tGPU演化成了Browser进程的一个线程\n    \tRenderer进程演化成了操作系统的一个服务进程,它仍然是独立的\n    ```\n\n    \n\n- 每个进程内部又有很多线程\n\n​\t\t\t多线程的目的主要是保持用户界面的高度响应\n\n​\t\t\t例如:为了不让Browser进程的UI线程被其他耗时的操作(大文件的加载,本地文件读写)所阻塞,那么我们就把这些操作放到分线程中去处理。在Renderer进程中,为了不让其他操作阻止渲染线程的高速执行,我们通常会将渲染过程【管线化】,利用计算机的多核优势,让渲染的不同阶段在不同的线程中执行。\n\n# 浏览器渲染引擎与阻塞\n\n## 一、浏览器渲染引擎\n\n### 主要模块\n\n- 一个渲染引擎主要包括：HTML解析器，css解析器，javascript引擎，布局layout模块，绘图模块\n  - HTML解析器：解析HTML文档的解析器，主要作用是将HTML文本解析成DOM树。\n  - CSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局模块提供基础设施\n  - Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，\n  - javascript引擎能够解析javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果\n  - 布局(layout)：在DOM创建之后，Webkit需要将其中的元素对象同样式结合器，计算它们的大小位置等布局信息，形成一个能表达这所有新信息的内部标识模型\n  - 绘图模块(paint)：使用图像库将布局计算后的各个网页的节点绘制成图像结果\n\n> 备注：文档对象模型（Document Object Model，简称DOM）\n\n### 大致的渲染过程\n\n- 浏览器渲染页面的整个过程：浏览器会从上到下解析文档\n\n  1. 遇见HTML标记，调用HTML解析器解析为对应的token（一个token就是一个标签文本的序列化）并构建DOM树（就是一块内存，保存着tokens，建立他们之间的关系）\n  2. 遇见style/link标记调用响应解析器处理css标记，并构建出css样式树\n  3. 遇见script标记调用javascript引擎处理script标记、绑定事件、修改DOM树/css树等\n  4. 将DOM树与CSS树合并为一个渲染树\n  5. 根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖GPU）\n  6. 最终将各个节点绘制到屏幕上\n\n  > 以上这些模块依赖很多其他的基础模块，包括要使用到网络 存储 2D/3D图像 音频视频解码器和图片解码器\n  >\n  > 所以渲染引擎中还会包括如何使用这些依赖模块的部分\n\n  \n\n## 二、阻塞渲染\n\n### 关于CSS阻塞\n\n> 声明：只有link引入的外部css才能够产生阻塞。\n\n1. style标签中的样式:\n   1. 由html解析器进行解析，浏览器加载资源是异步的；\n   2. 不阻塞浏览器渲染（可能会产生“闪屏现象”）；\n   3. 不阻塞DOM解析；\n2. link引入外部css样式（推荐使用的方式）\n   1. 由css解析器进行解析，并且是同步解析的；\n   2. 阻塞浏览器渲染（可以利用这种阻塞避免“闪屏现象”）；\n   3. 阻塞其后面的js语句的执行；\n   4. 不阻塞DOM的解析（绝大多数浏览器的工作方式）\n3. 优化核心理念：尽可能快的提高外部css加载速度\n   1. 使用CDN节点进行外部资源加速；\n   2. 对css进行压缩（利用打包工具）；\n   3. 减少http请求次数，将多个css文件合并\n   4. 优化样式表的代码\n\n### 关于JS阻塞\n\n1. 阻塞后续DOM解析：\n   1. 原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如`document.write`这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM。\n2. 阻塞页面渲染：\n   1. 原因：js中也可以给DOM设置样式，浏览器等该脚本执行完毕，渲染出一个最终结果，避免做无用功。\n3. 阻塞后续js的执行：\n   1. 原因：维护依赖关系，例如：必须引入jQuery在引入bootstrap\n\n## 三、备注\n\n​\t\t【备注一】：css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析。\n\n​\t\t【备注二】：无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本）。原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。这种做法效率很高。\n\n​\t\t【备注三】：webkit  和 Firefox 都进行了【预解析】这项优化。在执行js脚本时，浏览器的其他线程会预解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在提前加载，从而提高总体速度。预解析不会修改DOM树。\n\n> 在上述的过程中，网页在加载和渲染过程中会触发“DOMContentLoaded”和“onload”事件，分别是在DOM树构建（解析）完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后。\n>\n> script有一个defer属性，处于两者之间。\n\n# 图层与重绘重排\n\n## CSS图层\n\n​\t\t浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。`不管有没有创建图层，浏览器都会开启一个document的图层`\n\n​\t\t在渲染DOM的时候，浏览器的实际工作是：\n\n1. 获取DOM后分割为多个图层\n2. 对每个图层的节点计算样式结果   （Recalculate style --- 样式计算）\n3. 为每个节点生成图形和位置           （Layout  -- 布局，重排、回流）\n4. 将每个节点绘制填充到图层中 \t\t（Paint -- 重绘）\n5. 图层作为纹理上传至GPU\n6. 组合多个图层到页面上生成最终屏幕图像  （COmposite Layers -- 图层重组）\n\n## 图层的创建条件\n\nCHrome浏览器满足以下任意情况就会创建图层：\n\n- 具有3D变换的CSS属性\n\n```html\n<style type=\"text/css\">\n#wrap{\n    width: 200px;\n    height: 200px;\n    background: pink;\n    transform: translateZ(0); //3D变换属性\n}\n</style>\n<div id=\"wrap\"></div>\n```\n\n- 使用加速视频解码的video节点\n\n```html\n<video src=\"./media/test.mp4\" width=\"400\" height=\"400\" controls></video>\n```\n\n- canvas节点\n\n```html\n<canvas width=\"400\" height=\"400\"></canvas>\n<script type=\"text/javascript\">\n\t\n\twindow.onload=function(){\n\t\tvar canvas = document.querySelector(\"canvas\");\n\t\tif(canvas.getContext){\n\t\t\tvar ctx = canvas.getContext(\"2d\");\n\t\t\tctx.fillRect(0,0,100,100);\n\t\t\tctx.strokeRect(100,100,100,100);\n\t\t}\n\t}\n\t\n</script>\n```\n\n- CSS3动画的节点\n\n```html\n<style type=\"text/css\">\n\t*{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t\n\t@keyframes move{\n\t\tfrom{\n\t\t\tbackground-position: 0 0;\n\t\t}\n\t\tto{\n\t\t\tbackground-position: -576px 0;\n\t\t}\n\t}\n\t\n\t#wrap{\n\t\tposition: absolute;\n\t\tleft: 50%;\n\t\ttop: 50%;\n\t\ttransform: translate3d(-50%,-50%,0);\n\t\twidth: 48px;\n\t\theight: 48px;\n\t\tbackground: url(./media/animation.png);\n\t\tanimation: move .5s infinite  steps(12,start);\n\t}\n</style>\n<div id=\"wrap\"></div>\n```\n\n- 具有CSS加速属性的元素(will-change)\n\n```html\n<style type=\"text/css\">\n\t#wrap{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: pink;\n\t\twill-change:transform\n\t}\n</style>\n<div id=\"wrap\"></div>\n```\n\n## 重绘(Repaint)\n\n重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。\n\n> 注意：重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。所以为了提高性能，我们应该让这些“变化的东西”拥有自己的图层，不过绝大多数浏览器会为CSS3动画的节点自动创建图层。\n\n## 重排(Reflow 又称：回流)\n\n渲染对象在创建完成后并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排\n\n> “重绘”不一定需要重排，如改变某个网页元素的颜色，就只会触发“重绘”，不会触发“重排”，因为布局没有改变。\n>\n> “重排”大多数情况下会导致“重绘”，如改变一个网页元素的位置，就会同时触发“重排”和“重绘”，因为布局改变了。\n\n### 触发重绘的属性\n```\n      * color\t\t\t\t\t* background\t\t\t\t\t* outline-color\n      * border-style\t\t\t* background-image\t\t\t\t* outline\n      * border-radius\t\t\t* background-position\t\t\t* outline-style\n      * visibility\t\t\t\t* background-repeat\t\t\t\t* outline-width\n      * text-decoration\t\t\t* background-size\t\t\t\t* box-shadow\n```\n\n\n### 触发重排(回流)的属性\n```\n      * width\t\t\t\t\t  * top\t\t\t\t\t\t\t* text-align\n      * height\t\t\t\t\t  * bottom\t\t\t\t\t\t* overflow-y\n      * padding\t\t\t\t\t  * left\t\t\t\t\t\t* font-weight\n      * margin\t\t\t\t\t  * right\t\t\t\t\t\t* overflow\n      * display\t\t\t\t\t  * position\t\t\t\t\t* font-family\n      * border-width\t\t  \t  * float\t\t\t\t\t\t* line-height\n      * border\t\t\t\t\t  * clear\t\t\t\t\t\t* vertival-align\n      * min-height\t\t\t\t  * white-space\n```\n\n### 常见的触发重排的操作\n\n1. 增加、删除、修改DOM节点时，会导致 Reflow， Repaint\n2. 移动DOM的位置\n3. 修改CSS样式\n4. Resize窗口（移动端没有这个问题，因为移动端的缩放没有影响布局视口）\n5. 修改网页的默认字体\n6. 获取某些属性时（width，height....）\n\n> 注：display: none 会触发reflow，而visibility: hidden 只会触发 repaint，因为没有发生位置变化。\n>\n> Reflow（重排）的成本比Repaint（重绘）的成本高很多很多。\n>\n> 一个节点的Reflow很有可能导致子节点，甚至父节点以及同级节点的Reflow\n\n## 优化重排重绘方案\n\n浏览器渲染页面时经历了如下“细致”的环节：\n\n1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算）\n2. 为每个节点生成图形和位置（Layout--重排或回流）\n3. 将每个节点填充到图层中（Paint--重绘）\n4. 组合图层到页面上（Composite Layers--图层重组）\n\n如果我们需要提升性能，需要做的就是减少浏览器在运行时所需要做的工作，即：尽量减少1234步。\n\n```\n【具体优化方案如下】：\n1.元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作\n\t变换（transform）和透明度（opacity）的改变仅仅影响图层的组合\n2.【使用opacity来代替visibility】\n    (1).使用visibility不触发重排，但是依然重绘。\n    (2).直接使用opacity即触发重绘，又触发重排（GPU底层设计如此！）。\n    (3).opacity配合图层使用，即不触发重绘也不触发重排。\n        原因：\n\t\t透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。\n\t\t不过这个前提是这个被修改opacity本身必须是一个图层。\n3.【不要使用table布局】\n\ttable-cell\n4.将【多次改变样式属性的操作合并成一次】操作\n\t不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className\n5.【将DOM离线后再修改】\n\t由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。\n\t如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n6.【利用文档碎片】(documentFragment)------vue使用了该种方式提升性能。\n7.【不要把获取某些DOM节点的属性值放在一个循环里当成循环的变量】\n\t当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：\n\t\t1. offsetTop, offsetLeft, offsetWidth, offsetHeight\n\t\t2. scrollTop/Left/Width/Height\n\t\t3. clientTop/Left/Width/Height\n\t\t4. width,height\n    当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要刷新内部队列，\n    因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，\n    浏览器都会强行刷新渲染队列。\n8.动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)\n9.为动画元素新建图层,提高动画元素的z-index\n10.编写动画时，尽量使用如下的API\n```\n\n### requestAnimationFrame --- 请求动画帧\n\n1. window.requestAnimationFrame()\n\n   说明：该方法会告诉浏览器在下一次重绘重排之前调用指定的函数\n\n   参数：该方法使用一个回调函数作为参数，这个回调函数会在浏览器下一次重绘之前调用。回调函数会被自动传入一个参数，DOMHightResTimeStamp，标识requestAnimationFrame()开始触发回调函数的当前事件\n\n   返回值：一个long整数，请求ID，是回调列表中唯一的标识。是个非零值，没别的意义。传给window.calcelAnimationFrame()以取消回调函数。\n\n   > 备注：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()\n\n2. window.cancelAnimationFrame(requestID)\n\n   取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。requestID是先前调用window.requestAnimationFrame()方法时返回的值，它是一个时间标识，用法与定时器的id类似。\n\n# CDN\n\n## 什么是CND？工作原理是什么？\n\n网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容，为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。\n\n内容发布网络CDN(Content Delivery Networks)\n\n​\tCDN是一组分布在多个不同地理位置的web服务器，用于更加有效的向用户发布内容\n\n```\n基本思路：\n    尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n    通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，\n    CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息\n    将用户的请求重新导向离用户最近的服务节点上。\n基础架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成\n    1.用户输入的url，会经过DNS解析“翻译”成对应的ip地址，从而找到CDN专用的服务器。\n    2.CDN“拿到”用户的IP地址，随后和区域负载均衡设备配合，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。\n    3.上述步骤中的“选择”依据\n            (1).选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；\n            (2).根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；\n            (3).查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。\n```\n\n# 函数防抖和节流\n\n## 防抖(debounce)\n\n- 概念： 延迟要执行的动作，若在延时的这段时间内，再次触发了，则取消之前开启的动作，重新计时。\n- 举例： 电脑无操作1分钟之内如果没有操作会进入休眠，当第40秒时鼠标被移动一下，重新计时1分钟。\n- 实现： 定时器。\n- 应用：搜索时等用户完整输入内容后再发送查询请求。\n\n## 节流(throttle)\n\n- 概念：设定一个特定的时间，让函数在特定的时间内只执行一次，不会频繁执行\n- 举例：fps游戏，鼠标按住不松手，子弹也不会连成一条线\n- 实现：定时器、标识\n- 需求：在鼠标滚轮滚动的时候，每隔2秒钟，打印一次\n\n# 浏览器本地存储\n\n## 浏览器存储\n\n\tCookie, SessionStorage, LocalStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对！\n\t\n\t注意：session和SessionStorage不是一个概念！！！在服务端有一种存储方式叫做：session会话存储，常常被简称session\n\n## Web Storage\n\n\tSessionStorage和LocalStorage都是浏览器本地存储，统称为Web Storage，存储内容大小一般支持5-10MB\n\t浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\t\n\t相关API：\n\t1. localStorage.setItem('key', 'value');\n\t\t\t该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\t\t\t\n\t2. var data = xxxxxStorage.getItem('person');\n\t\t该方法接受一个键名作为参数，返回键名对应的值。\n\t\n\t3. xxxxxStorage.removeItem('key');\n\t\t该方法接受一个键名作为参数，并把该键名从存储中删除。\n\t\t\n\t4. xxxxxStorage.clear()\n\t\t调用该方法会清空存储中的所有键名\n\t\n\t备注：SessionStorage存储的内容会随着浏览器窗口关闭而消失。\n\t      LocalStorage存储的内容，需要手动清除才会消失。\n\n> storage事件：\t\n> \t1. Storage对象发生变化时触发（即创建/更新/删除数据项时，Storage.clear() 只会触发一次）\n> \t2. 在同一个页面内发生的改变不会起作用\n> \t3. 在相同域名下的其他页面发生的改变才会起作用。(修改的页面不会触发事件，与它共享的页面会触发事件)\n> \t\tkey \t    :  修改或删除的key值，如果调用clear(),为null\n> \t\tnewValue    :  新设置的值，如果调用clear(),为null\n> \t\toldValue    :  调用改变前的value值,如果调用clear(),为null\n> \t\turl         :  触发该脚本变化的文档的url\n> \t\tstorageArea :  当前的storage对象\n> \t\t使用方法：\n>          \t window.addEventListener('storage', function (event) {\n>             \t//此处写具体业务逻辑\n>          \t })\n\n# 缓存机制\n\n## 1. 缓存理解\n\n    1. 缓存定义:\n           1. 浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要改数据的时候无需再次发送请求，直接从浏览器本地获取数据\n    2. 缓存的好处:\n           1. 减少请求的个数\n           2. 节省带宽，避免浪费不必要的网络资源\n           3. 减轻服务器压力\n           4. 提高浏览器网页的加载速度，提高用户体验\n\n## 2. 缓存分类\n\n    1. 强缓存\n           1. 不会向服务器发送请求，直接从本地缓存中获取数据\n           2. 请求资源的的状态码为: 200 ok(from memory cache)\n    2. 协商缓存\n           1. 向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存\n           2. 如果命中，则返回304状态码通知浏览器从缓存中读取资源\n    3. 强缓存 & 协商缓存的共同点\n           1. 都是从浏览器端读取资源\n    4. 强缓存 VS 协商缓存的不同点\n       1. 强缓存不发请求给服务器\n       2. 协商缓存发请求给服务器，根据服务器返回的信息决定是否使用缓存\n\n## 3. 缓存使用示意图\n\n![](https://raw.githubusercontent.com/ZenDevon/blog-img/main/V7f829.png)\n\n## 4. 缓存中的header参数\n\n### 1、强缓存的header参数\n\n----------\n\n    1. expires：\n           1. 这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如```Mon, 10 Jun 2015 21:31:12 GMT```，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源\n    2. cache-control：max-age=number\n           1. 这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；\n         2. cache-control常用的值（做一个简单了解即可）：\n         2. no-cache: 不使用本地缓存，需要使用协商缓存。先与服务器确认返回的响应是否被更改，如果之前的响应中存在Etag，那么请求的额时候会与服务器端进行验证，如果资源为被更改则使用缓存。\n         3. no-store: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\n         4. public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\n         5. private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\n            2. <font color=red>注意：当cache-control与Expires共存的时候cache-control的优先级高</font>\n\n### 2、协商缓存的header参数\n\n----------\n\n  <font color=red> 重点：协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问</font>\n\n  * Last-Modified/If-Modified-Since:二者的值都是GMT格式的时间字符串\n\n      1.  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间\n      2.  浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值\n      3.  服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header\n      4.  浏览器收到304的响应后，就会从缓存中加载资源\n      5.  如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值\n      6.  图例：![](https://i.imgur.com/GZqqDbS.png)\n\n-----------\n\n   * Etag/If-None-Match\n     1. 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变\n     2. 其判断过程与Last-Modified/If-Modified-Since类似\n\n-----------\n\n  * 既生Last-Modified何生Etag\n    1. HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题\n    2. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET\n    3. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\n    4. 某些服务器不能精确的得到文件的最后修改时间。\n\n-----------\n\n  * 小结：\n    * 利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\n\n    * Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。\n\n## 5. 强缓存如何重新加载新的资源\n\n  * 通过更新页面中引用的资源路径，让浏览器主动放弃加载缓存去加载新的资源\n  * 示例：```https://www.baidu.com/s?t=7aec0h3KB3Ba8lAbuyPg0AC0eDa59IvtDSmtMQBc6eW ```\n  * 好处：\n    * 每次文件改变后query的值就会发生修改，当query值不同的时候也就是页面引用的资源路径不同。此时浏览器会主动加载新的资源。\n","tags":["前端","性能优化"]},{"title":"JavaScript面试题","url":"/2024/05/27/JavaScript面试题/","content":"\n# bind、call、apply 区别？\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/a900e460-7be4-11eb-ab90-d9ae814b240d.png)\n\n## 一、作用\n\n`call `、`apply `、`bind `作用是改变函数执行时的上下文，简而言之就是改变函数运行时的`this`指向\n\n那么什么情况下需要改变`this`的指向呢？下面举个例子\n\n```javascript\nvar name=\"awen\";\nconst obj={\n    name:\"zendevon\",\n    say:function () {\n        console.log(this.name);\n    }\n};\nobj.say(); //zendevon，this指向obj对象\nsetTimeout(obj.say,0); //awen，this指向window对象\n```\n\n从上面可以看到，正常情况`say`方法输出`zendevon`\n\n但是我们把`say`放在`setTimeout`方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候`this`指向`window`，所以输出`awen`\n\n我们实际需要的是`this`指向`obj`对象，这时候就需要该改变`this`指向了\n\n```javascript\nsetTimeout(obj.say.bind(obj),0); //zendevon，this指向obj对象\n```\n\n## 二、区别\n\n下面再来看看`apply`、`call`、`bind`的使用\n\n### apply\n\n`apply`接受两个参数，第一个参数是`this`的指向，第二个参数是函数接受的参数，以数组的形式传入\n\n改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次\n\n```javascript\nfunction fn(...args){\n    console.log(this,args);\n}\nlet obj = {\n    myname:\"张三\"\n}\n\nfn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组；\nfn(1,2) // this指向window\n```\n\n\n\n当第一个参数为`null`、`undefined`的时候，默认指向`window`(在浏览器中)\n\n```javascript\nfn.apply(null,[1,2]); // this指向window\nfn.apply(undefined,[1,2]); // this指向window\n```\n\n\n\n### call\n\n`call`方法的第一个参数也是`this`的指向，后面传入的是一个参数列表\n\n跟`apply`一样，改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次\n\n```javascript\nfunction fn(...args){\n    console.log(this,args);\n}\nlet obj = {\n    myname:\"张三\"\n}\n\nfn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是一个数组；\nfn(1,2) // this指向window\n```\n\n\n\n同样的，当第一个参数为`null`、`undefined`的时候，默认指向`window`(在浏览器中)\n\n```javascript\nfn.call(null,[1,2]); // this指向window\nfn.call(undefined,[1,2]); // this指向window\n```\n\n\n\n### bind\n\nbind方法和call很相似，第一参数也是`this`的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)\n\n改变`this`指向后不会立即执行，而是返回一个永久改变`this`指向的函数\n\n```javascript\nfunction fn(...args){\n    console.log(this,args);\n}\nlet obj = {\n    myname:\"张三\"\n}\n\nconst bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次\nbindFn(1,2) // this指向obj\nfn(1,2) // this指向window\n```\n\n### 小结\n\n从上面可以看到，`apply`、`call`、`bind`三者的区别在于：\n\n- 三者都可以改变函数的`this`对象指向\n- 三者第一个参数都是`this`要指向的对象，如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`\n- 三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入\n- `bind `是返回绑定this之后的函数，`apply `、`call` 则是立即执行\n\n\n\n","tags":["面试题","前端"]},{"title":"记录和你在一起的每一天","url":"/2024/05/20/和你的520/","content":"## 和鑫鑫公主的第一个520\n在这个特殊的520日子里，我与鑫鑫公主一同度过了属于我们的美好时光。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240520210012.jpg)\n\n人生之中第一次收到花哎，谢谢鑫鑫公主\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240520210009.jpg)\n\n感谢有鑫鑫公主的陪伴，让我们的第一个520如此难忘。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240520210005.jpg)\n\n希望在未来的日子里，我们依然能够携手同行，一起度过未来的每一个520。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240520210024.jpg)\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240520210022.jpg)\n\n","tags":["生活"]},{"title":"NodeJs中http模块","url":"/2024/05/20/NodeJs中http模块/","content":"\n## Web服务器\n- 什么是Web服务器？\n    - 当应用程序（客户端）需要某一个资源时，可以向一个台服务器，通过Http请求获取到这个资源；提供资源的这个服务器，就是一个Web服务器；\n    ![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信截图_20240520211048.png)\n-  目前有很多开源的Web服务器：Nginx、Apache（静态）、Apache Tomcat（静态、动态）、Node.js\n\n## Web服务器初体验\n\n``` javascript\nconst http = require(\"express\");\nconst HTTP_PORT = 8000;\n\nconst server = http.createServer((req, res) => {\n    res.end(\"Hello World\");\n})\n\nserver.listen(HTTP_PORT, () => {\n    console.log(`服务器在${HTTP_PORT}启动成功~`);\n})\n```\n- 创建Server时会传入一个回调函数，这个回调函数在被调用时会传入两个参数：\n    - req：request请求对象，包含请求相关的信息；\n    - res：response响应对象，包含我们要发送给客户端的信息\n\n","tags":["前端","Node"]},{"title":"事件循环","url":"/2024/05/14/事件循环/","content":"## 事件循环是什么？\n- 所谓的事件循环就是我们编写的JavaScript代码和浏览器或者Node之间的一个桥梁。\n- 浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout/AJAX/监听事件等)的一个桥梁,  桥梁之间他们通过回调函数进行沟通。\n- Node的事件循环是一个我们编写的JavaScript代码和系统调用（file system、network等）之间的一个桥梁, 桥梁 之间他们通过回调函数进行沟通的。\n\n## 进程和线程\n### 线程和进程是操作系统中的两个概念： \n- 进程（process）：计算机已经运行的程序。我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程)\n- 线程（thread）：操作系统能够运行运算调度的最小单位。每一个进程中，都会启动一个线程用来执行程序中的代码，这个线程被称之为主线程\n- 所以我们也可以说进程是线程的容器\n### 再用一个形象的例子解释：\n- 操作系统类似于一个工厂\n- 工厂中里有很多车间，这个车间就是进程\n- 每个车间可能有一个以上的工人在工厂，这个工人就是线程\n\n## 浏览器时间循环\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信截图_20240514135030.png)\n\n## 宏任务和微任务\n### 事件循环中并非只维护着一个队列，事实上是有两个队列\n\n- 宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等\n- 微任务队列（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等\n\n<span style=\"color: red\">async、await是Promise的一个语法糖<span>\n\n<span style=\"color: red\">我们可以将await关键词后面执行的代码，看作是包裹在(resolve, reject) => {函数执行}中的代码<span>\n\n<span style=\"color: red\">await的下一条语句，可以看作是then(res => {函数执行}中的代码)<span>\n\n\n\n### 事件循环对于两个队列的优先级是怎么样的呢\n\n- main script中的代码优先执行（编写的顶层script代码）\n- 在执行任何一个宏任务之前（不是队列，是一个宏任务），都会先查看微任务队列中是否有任务需要执行\n  - 也就是宏任务执行之前，必须保证微任务队列是空的\n  - 如果不为空，那么久优先执行微任务队列中的任务（回调）\n\n\n","tags":["前端"]},{"title":"洛阳行","url":"/2024/05/13/洛阳行/","content":"## 洛阳三日游\n\n二〇二四年五月，我和女友踏上了前往洛阳的旅程，去感受这座古都的魅力。\n\n经过长达15个小时的火车旅程，我们终于抵达了洛阳。尽管满身疲惫，但一想到即将开始探索这座古都，我们的疲惫就一扫而空。在火车上我们拍了一张合照，以此记录这趟旅程的开始。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184551.jpg)\n\n下火车后，我们便直接前往龙门石窟。这里的石刻艺术精湛绝伦，每一尊佛像都栩栩如生，仿佛正在向我们诉说古老的故事，让我们深深感受到历史的厚重。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184554.jpg)\n\n离开龙门石窟，我们坐公交车前往了王城公园。在这里，我们体验了刺激的大摆锤和过山车。随着机器启动，我们瞬间被抛向高空，那种刺激与快感让我们忍不住尖叫起来。过山车在轨道上飞驰，转弯、俯冲，每一个动作都让我们心跳加速，兴奋不已。而大摆锤更是让我们感受到了前所未有的失重感，仿佛整个人都要飞出去了。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184559.jpg)\n\n之后，我们还参观了王城公园的动物园。这里有各种各样的动物，可爱的猴子、憨厚的大象、威猛的狮子……我们一边观赏，一边拍照留念。特别是那些可爱的小动物，让我们忍不住想要上前去摸摸它们。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510190201.jpg)\n\n原本计划第二天早起游览多个景点，但我们都睡过了头，直到中午才起床。虽然错过了早晨的美景，但我们还是决定前往白马寺。这座古朴典雅的寺庙给我们留下了深刻的印象。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184556.jpg)\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184548.jpg)\n\n晚上，我们骑着电动车游览了九州池。这里的夜景如诗如画，仿佛置身于仙境之中。我努力学习拍照技巧，想捕捉下这迷人的夜景和女友美丽的身影。\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240510184540.jpg)\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184543.jpg)\n\n![img](https://raw.githubusercontent.com/ZenDevon/blog-img/main/微信图片_20240510184545.jpg)\n\n第三天，我们参观了洛阳古墓博物馆。这里展示了古代墓葬的壮观景象，让我们对古代文明和历史文化有了更深刻的认识和理解。\n\n洛阳之行充满了欢乐与收获。未来和女友一起出行更多的地方。\n","tags":["旅行","生活"]}]